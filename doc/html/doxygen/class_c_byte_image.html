<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>IVT: CByteImage Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">IVT
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_c_byte_image.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_c_byte_image-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CByteImage Class Reference<div class="ingroups"><a class="el" href="group___image_representations.html">Image representations</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images using the data type unsigned char.  
 <a href="class_c_byte_image.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_byte_image_8h_source.html">ByteImage.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a694d6dc28b747d8a972130106a529f9e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9e">ImageType</a> { <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f">eGrayScale</a>, 
<a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea54e3db17b589f4643db4ae3663e34278">eRGB24</a>, 
<a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea49137e7257d209b4b831bb271c2f69bf">eRGB24Split</a>
 }</td></tr>
<tr class="memdesc:a694d6dc28b747d8a972130106a529f9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum specifying the supported image types.  <a href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9e">More...</a><br/></td></tr>
<tr class="separator:a694d6dc28b747d8a972130106a529f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a443e3009a867ec78eb38e122d73da1cc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_byte_image.html#a443e3009a867ec78eb38e122d73da1cc">CByteImage</a> ()</td></tr>
<tr class="memdesc:a443e3009a867ec78eb38e122d73da1cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default constructor.  <a href="#a443e3009a867ec78eb38e122d73da1cc">More...</a><br/></td></tr>
<tr class="separator:a443e3009a867ec78eb38e122d73da1cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9e594a1a68db006ba787496d5aa664"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_byte_image.html#a1f9e594a1a68db006ba787496d5aa664">CByteImage</a> (int nImageWidth, int nImageHeight, <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9e">ImageType</a> imageType, bool bHeaderOnly=false)</td></tr>
<tr class="memdesc:a1f9e594a1a68db006ba787496d5aa664"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for creating an image of a specific size and type.  <a href="#a1f9e594a1a68db006ba787496d5aa664">More...</a><br/></td></tr>
<tr class="separator:a1f9e594a1a68db006ba787496d5aa664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2475fc3def3c704d8ae6a33db7603a6c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_byte_image.html#a2475fc3def3c704d8ae6a33db7603a6c">CByteImage</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pImage, bool bHeaderOnly=false)</td></tr>
<tr class="memdesc:a2475fc3def3c704d8ae6a33db7603a6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for creating an image given a pointer to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>.  <a href="#a2475fc3def3c704d8ae6a33db7603a6c">More...</a><br/></td></tr>
<tr class="separator:a2475fc3def3c704d8ae6a33db7603a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6529466bea296a010dff4ca9ae47459b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_byte_image.html#a6529466bea296a010dff4ca9ae47459b">CByteImage</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> &amp;image, bool bHeaderOnly=false)</td></tr>
<tr class="memdesc:a6529466bea296a010dff4ca9ae47459b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a6529466bea296a010dff4ca9ae47459b">More...</a><br/></td></tr>
<tr class="separator:a6529466bea296a010dff4ca9ae47459b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac119d5a2b96d3bf2231064e90eb44ca1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_byte_image.html#ac119d5a2b96d3bf2231064e90eb44ca1">~CByteImage</a> ()</td></tr>
<tr class="memdesc:ac119d5a2b96d3bf2231064e90eb44ca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The destructor.  <a href="#ac119d5a2b96d3bf2231064e90eb44ca1">More...</a><br/></td></tr>
<tr class="separator:ac119d5a2b96d3bf2231064e90eb44ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a273d2260b46eb51bf50ae5bef4d623"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_byte_image.html#a6a273d2260b46eb51bf50ae5bef4d623">Set</a> (int nImageWidth, int nImageHeight, <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9e">ImageType</a> imageType, bool bHeaderOnly=false)</td></tr>
<tr class="memdesc:a6a273d2260b46eb51bf50ae5bef4d623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes size and type of an image.  <a href="#a6a273d2260b46eb51bf50ae5bef4d623">More...</a><br/></td></tr>
<tr class="separator:a6a273d2260b46eb51bf50ae5bef4d623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8055517ba0b467b891f1ce8a2e71e24d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_byte_image.html#a8055517ba0b467b891f1ce8a2e71e24d">IsCompatible</a> (const <a class="el" href="class_c_byte_image.html">CByteImage</a> *pImage) const </td></tr>
<tr class="memdesc:a8055517ba0b467b891f1ce8a2e71e24d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether two images are compatible or not.  <a href="#a8055517ba0b467b891f1ce8a2e71e24d">More...</a><br/></td></tr>
<tr class="separator:a8055517ba0b467b891f1ce8a2e71e24d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe475517d33842dfe6378f76f737743b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_byte_image.html#afe475517d33842dfe6378f76f737743b">LoadFromFile</a> (const char *pFileName)</td></tr>
<tr class="memdesc:afe475517d33842dfe6378f76f737743b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads an image from a file.  <a href="#afe475517d33842dfe6378f76f737743b">More...</a><br/></td></tr>
<tr class="separator:afe475517d33842dfe6378f76f737743b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9441ebefe12b30c9b673d87811233b9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_byte_image.html#ab9441ebefe12b30c9b673d87811233b9">SaveToFile</a> (const char *pFileName) const </td></tr>
<tr class="memdesc:ab9441ebefe12b30c9b673d87811233b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves an image to a file.  <a href="#ab9441ebefe12b30c9b673d87811233b9">More...</a><br/></td></tr>
<tr class="separator:ab9441ebefe12b30c9b673d87811233b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aeb83a0ce3987f6a45207fba0d211dbeb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_byte_image.html#aeb83a0ce3987f6a45207fba0d211dbeb">width</a></td></tr>
<tr class="memdesc:aeb83a0ce3987f6a45207fba0d211dbeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The width of the image in pixels.  <a href="#aeb83a0ce3987f6a45207fba0d211dbeb">More...</a><br/></td></tr>
<tr class="separator:aeb83a0ce3987f6a45207fba0d211dbeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad83b58f53758148e02582ba20b59dbf3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_byte_image.html#ad83b58f53758148e02582ba20b59dbf3">height</a></td></tr>
<tr class="memdesc:ad83b58f53758148e02582ba20b59dbf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The height of the image in pixels.  <a href="#ad83b58f53758148e02582ba20b59dbf3">More...</a><br/></td></tr>
<tr class="separator:ad83b58f53758148e02582ba20b59dbf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d0d2b65dbd19cff2aff10eb7f01a76"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_byte_image.html#a60d0d2b65dbd19cff2aff10eb7f01a76">bytesPerPixel</a></td></tr>
<tr class="memdesc:a60d0d2b65dbd19cff2aff10eb7f01a76"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of bytes used for encoding one pixel.  <a href="#a60d0d2b65dbd19cff2aff10eb7f01a76">More...</a><br/></td></tr>
<tr class="separator:a60d0d2b65dbd19cff2aff10eb7f01a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0393555a29bdcb652481cdb7ee44fd1b"><td class="memItemLeft" align="right" valign="top">unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_byte_image.html#a0393555a29bdcb652481cdb7ee44fd1b">pixels</a></td></tr>
<tr class="memdesc:a0393555a29bdcb652481cdb7ee44fd1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pointer to the the pixels.  <a href="#a0393555a29bdcb652481cdb7ee44fd1b">More...</a><br/></td></tr>
<tr class="separator:a0393555a29bdcb652481cdb7ee44fd1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89c8cddbca2d69a8b21da51ada8d70c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9e">ImageType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_byte_image.html#a89c8cddbca2d69a8b21da51ada8d70c1">type</a></td></tr>
<tr class="memdesc:a89c8cddbca2d69a8b21da51ada8d70c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the image.  <a href="#a89c8cddbca2d69a8b21da51ada8d70c1">More...</a><br/></td></tr>
<tr class="separator:a89c8cddbca2d69a8b21da51ada8d70c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05e313b4e6bb6d8d032ada9d5357a870"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_byte_image.html#a05e313b4e6bb6d8d032ada9d5357a870">m_bOwnMemory</a></td></tr>
<tr class="memdesc:a05e313b4e6bb6d8d032ada9d5357a870"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag signaling if memory is to be freed or not.  <a href="#a05e313b4e6bb6d8d032ada9d5357a870">More...</a><br/></td></tr>
<tr class="separator:a05e313b4e6bb6d8d032ada9d5357a870"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images using the data type unsigned char. </p>
<p><a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> is the central class for the representation of grayscale and color images.</p>
<p>Images of type <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> can be directly loaded from or stored to files and visualized in GUIs. The image data is represented as a linear array of pixels, always starting from the top left corner and stored row wise.</p>
<p>In the case of grayscale images (CByteImage::eGraySclae), the grayscale value of each pixel is encoded in one byte (0: black, 255: white, nuances in between). In the case of 24-bit color images the color information of each pixel is encoded in three bytes (first: red, second: green, third: blue).</p>
<p>For 24-bit color images two variants are available: <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea54e3db17b589f4643db4ae3663e34278">CByteImage::eRGB24</a> and <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9ea49137e7257d209b4b831bb271c2f69bf">CByteImage::eRGB24Split</a>, the first encoding the three components of an RGB triple in three consecutive bytes, the latter encoding the three components in three separate channels (the first starting at <a class="el" href="class_c_byte_image.html#a0393555a29bdcb652481cdb7ee44fd1b" title="The pointer to the the pixels. ">CByteImage::pixels</a>, the second at <a class="el" href="class_c_byte_image.html#a0393555a29bdcb652481cdb7ee44fd1b" title="The pointer to the the pixels. ">CByteImage::pixels</a> + <a class="el" href="class_c_byte_image.html#aeb83a0ce3987f6a45207fba0d211dbeb" title="The width of the image in pixels. ">CByteImage::width</a> * <a class="el" href="class_c_byte_image.html#ad83b58f53758148e02582ba20b59dbf3" title="The height of the image in pixels. ">CByteImage::height</a>, and the third starting at <a class="el" href="class_c_byte_image.html#a0393555a29bdcb652481cdb7ee44fd1b" title="The pointer to the the pixels. ">CByteImage::pixels</a> + 2 * <a class="el" href="class_c_byte_image.html#aeb83a0ce3987f6a45207fba0d211dbeb" title="The width of the image in pixels. ">CByteImage::width</a> * <a class="el" href="class_c_byte_image.html#ad83b58f53758148e02582ba20b59dbf3" title="The height of the image in pixels. ">CByteImage::height</a>. </p>

<p>Definition at line <a class="el" href="_byte_image_8h_source.html#l00080">80</a> of file <a class="el" href="_byte_image_8h_source.html">ByteImage.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a694d6dc28b747d8a972130106a529f9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9e">CByteImage::ImageType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enum specifying the supported image types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a694d6dc28b747d8a972130106a529f9ea4e26f5d8eb810a3ba6410c8d924a457f"></a>eGrayScale</em>&#160;</td><td class="fielddoc">
<p>In the case of grayscale images the grayscale value of each pixel is encoded in one byte (0: black, 255: white). </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a694d6dc28b747d8a972130106a529f9ea54e3db17b589f4643db4ae3663e34278"></a>eRGB24</em>&#160;</td><td class="fielddoc">
<p>Each pixel is encoded in three consecutive bytes (first: red, second: green, third: blue). </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a694d6dc28b747d8a972130106a529f9ea49137e7257d209b4b831bb271c2f69bf"></a>eRGB24Split</em>&#160;</td><td class="fielddoc">
<p>The RGB color information is storted in three separate channels (the first starting at <a class="el" href="class_c_byte_image.html#a0393555a29bdcb652481cdb7ee44fd1b" title="The pointer to the the pixels. ">CByteImage::pixels</a>, the second at <a class="el" href="class_c_byte_image.html#a0393555a29bdcb652481cdb7ee44fd1b" title="The pointer to the the pixels. ">CByteImage::pixels</a> + <a class="el" href="class_c_byte_image.html#aeb83a0ce3987f6a45207fba0d211dbeb" title="The width of the image in pixels. ">CByteImage::width</a> * <a class="el" href="class_c_byte_image.html#ad83b58f53758148e02582ba20b59dbf3" title="The height of the image in pixels. ">CByteImage::height</a>, and the third starting atCByteImage:: pixels + 2 * <a class="el" href="class_c_byte_image.html#aeb83a0ce3987f6a45207fba0d211dbeb" title="The width of the image in pixels. ">CByteImage::width</a> * <a class="el" href="class_c_byte_image.html#ad83b58f53758148e02582ba20b59dbf3" title="The height of the image in pixels. ">CByteImage::height</a>. </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="_byte_image_8h_source.html#l00086">86</a> of file <a class="el" href="_byte_image_8h_source.html">ByteImage.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a443e3009a867ec78eb38e122d73da1cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CByteImage::CByteImage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The default constructor. </p>
<p>The default constructor sets all member variables to zero, i.e. after construction no valid image is represented.</p>
<p>This constructor is useful in case an image is to be loaded from a file at a later point, e.g. with the method <a class="el" href="class_c_byte_image.html#afe475517d33842dfe6378f76f737743b" title="Loads an image from a file. ">LoadFromFile(const char *)</a>. </p>

<p>Definition at line <a class="el" href="_byte_image_8cpp_source.html#l00080">80</a> of file <a class="el" href="_byte_image_8cpp_source.html">ByteImage.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1f9e594a1a68db006ba787496d5aa664"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CByteImage::CByteImage </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nImageWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nImageHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9e">ImageType</a>&#160;</td>
          <td class="paramname"><em>imageType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bHeaderOnly</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for creating an image of a specific size and type. </p>
<p>With this constructor, an instance of <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> is created, given the desired image resolution and image type. The contents of the image are not initialized, i.e. are undefined after creation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nImageWidth</td><td>The desired width of the image in pixels. Must be &gt; 0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nImageHeight</td><td>The desired height of the image in pixels. Must be &gt; 0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">imageType</td><td>The desired type of the image. See ImageType for further information. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bHeaderOnly</td><td>If set to false (default value), memory is allocated for the pixels. If set to true, no memory is allocated for the pixels. The latter can be useful for assigning image data from other sources (see e.g. implementation of <a class="el" href="namespace_image_access_c_v.html#a62777e2a43c95f68e6cc9b31d44d51eb" title="Loads an image from a file. ">ImageAccessCV::LoadFromFile</a>). Note that if bHeaderOnly is set to true, the member variable <a class="el" href="class_c_byte_image.html#a05e313b4e6bb6d8d032ada9d5357a870" title="Flag signaling if memory is to be freed or not. ">CByteImage::m_bOwnMemory</a> is set to false so that memory assigned to the member variable <a class="el" href="class_c_byte_image.html#a0393555a29bdcb652481cdb7ee44fd1b" title="The pointer to the the pixels. ">CByteImage::pixels</a> is not freed throughout re-initialization/destruction, i.e. freeing memory must be handled by the caller in this case. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_byte_image_8cpp_source.html#l00090">90</a> of file <a class="el" href="_byte_image_8cpp_source.html">ByteImage.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2475fc3def3c704d8ae6a33db7603a6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CByteImage::CByteImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pImage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bHeaderOnly</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for creating an image given a pointer to a <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a>. </p>
<p>This constructor creates a new instance with the same properties as the image provided by the parameter 'pImage'. <b>Note that the contents of the image are not copied.</b> Use <a class="el" href="namespace_image_processor.html#a2ec48acb91186120a1fd9f53fe1c76a4" title="Copies one CByteImage to another. ">ImageProcessor::CopyImage(const CByteImage*, CByteImage*, const MyRegion*, bool)</a> for copying image contents.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pImage</td><td>The template image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bHeaderOnly</td><td>If set to false (default value), memory is allocated for the pixels. If set to true, no memory is allocated for the pixels. The latter can be useful for assigning image data from other sources (see e.g. implementation of <a class="el" href="namespace_image_access_c_v.html#a62777e2a43c95f68e6cc9b31d44d51eb" title="Loads an image from a file. ">ImageAccessCV::LoadFromFile</a>). Note that if bHeaderOnly is set to true, the member variable <a class="el" href="class_c_byte_image.html#a05e313b4e6bb6d8d032ada9d5357a870" title="Flag signaling if memory is to be freed or not. ">CByteImage::m_bOwnMemory</a> is set to false so that memory assigned to the member variable <a class="el" href="class_c_byte_image.html#a0393555a29bdcb652481cdb7ee44fd1b" title="The pointer to the the pixels. ">CByteImage::pixels</a> is not freed throughout re-initialization/destruction, i.e. freeing memory must be handled by the caller in this case. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_byte_image_8cpp_source.html#l00139">139</a> of file <a class="el" href="_byte_image_8cpp_source.html">ByteImage.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6529466bea296a010dff4ca9ae47459b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CByteImage::CByteImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> &amp;&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bHeaderOnly</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>This copy constructor creates a new instance with the same properties as the image provided by the parameter 'image'. <b>Note that the contents of the image are not copied.</b> Use <a class="el" href="namespace_image_processor.html#a2ec48acb91186120a1fd9f53fe1c76a4" title="Copies one CByteImage to another. ">ImageProcessor::CopyImage(const CByteImage*, CByteImage*, const MyRegion*, bool)</a> for copying image contents.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">image</td><td>The template image. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bHeaderOnly</td><td>If set to false (default value), memory is allocated for the pixels. If set to true, no memory is allocated for the pixels. The latter can be useful for assigning image data from other sources (see e.g. implementation of <a class="el" href="namespace_image_access_c_v.html#a62777e2a43c95f68e6cc9b31d44d51eb" title="Loads an image from a file. ">ImageAccessCV::LoadFromFile</a>). Note that if bHeaderOnly is set to true, the member variable <a class="el" href="class_c_byte_image.html#a05e313b4e6bb6d8d032ada9d5357a870" title="Flag signaling if memory is to be freed or not. ">CByteImage::m_bOwnMemory</a> is set to false so that memory assigned to the member variable <a class="el" href="class_c_byte_image.html#a0393555a29bdcb652481cdb7ee44fd1b" title="The pointer to the the pixels. ">CByteImage::pixels</a> is not freed throughout re-initialization/destruction, i.e. freeing memory must be handled by the caller in this case. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_byte_image_8cpp_source.html#l00120">120</a> of file <a class="el" href="_byte_image_8cpp_source.html">ByteImage.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac119d5a2b96d3bf2231064e90eb44ca1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CByteImage::~CByteImage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The destructor. </p>

<p>Definition at line <a class="el" href="_byte_image_8cpp_source.html#l00158">158</a> of file <a class="el" href="_byte_image_8cpp_source.html">ByteImage.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a8055517ba0b467b891f1ce8a2e71e24d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CByteImage::IsCompatible </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_byte_image.html">CByteImage</a> *&#160;</td>
          <td class="paramname"><em>pImage</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether two images are compatible or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pImage</td><td>Pointer to the image to be checked compatibility with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the attributes width, height and type are equal, otherwise returns false. </dd></dl>

<p>Definition at line <a class="el" href="_byte_image_8cpp_source.html#l00212">212</a> of file <a class="el" href="_byte_image_8cpp_source.html">ByteImage.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="afe475517d33842dfe6378f76f737743b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CByteImage::LoadFromFile </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pFileName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads an image from a file. </p>
<p>Loads an image from a BMP, PGM, or PPM file. The image type is recognized by the file name ending (.bmp, .pgm, .ppm or .BMP, .PGM, .PPM).</p>
<p>If an image is already loaded, reinitialization is performed automatically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pFileName</td><td>The path to the image file to be loaded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success and false on failure. </dd></dl>

<p>Definition at line <a class="el" href="_byte_image_8cpp_source.html#l00232">232</a> of file <a class="el" href="_byte_image_8cpp_source.html">ByteImage.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab9441ebefe12b30c9b673d87811233b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CByteImage::SaveToFile </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pFileName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves an image to a file. </p>
<p>Saves the current image to a BMP, PGM, or PPM file. The desired image type is recognized by the file name ending (.bmp, .pgm, .ppm or .BMP, .PGM, .PPM).</p>
<p><b>Be careful to provide the correct file ending for PGM/PPM files</b>: <b>.PGM</b> for <em>grayscale</em> images or <b>.PPM</b> for <em>RGB</em> images.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pFileName</td><td>The path to the destination file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success and false on failure. </dd></dl>

<p>Definition at line <a class="el" href="_byte_image_8cpp_source.html#l00243">243</a> of file <a class="el" href="_byte_image_8cpp_source.html">ByteImage.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6a273d2260b46eb51bf50ae5bef4d623"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CByteImage::Set </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nImageWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nImageHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9e">ImageType</a>&#160;</td>
          <td class="paramname"><em>imageType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bHeaderOnly</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes size and type of an image. </p>
<p>With this method, an existing instance of <a class="el" href="class_c_byte_image.html" title="Data structure for the representation of 8-bit grayscale images and 24-bit RGB (or HSV) color images ...">CByteImage</a> is changed, given the desired image resolution and image type. The contents of the image are not initialized after calling this method, i.e. are undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nImageWidth</td><td>The desired width of the image in pixels. Must be &gt; 0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nImageHeight</td><td>The desired height of the image in pixels. Must be &gt; 0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">imageType</td><td>The desired type of the image. See ImageType for further information. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bHeaderOnly</td><td>If set to false (default value), memory is allocated for the pixels. If set to true, no memory is allocated for the pixels. The latter can be useful for assigning image data from other sources (see e.g. implementation of <a class="el" href="namespace_image_access_c_v.html#a62777e2a43c95f68e6cc9b31d44d51eb" title="Loads an image from a file. ">ImageAccessCV::LoadFromFile</a>). Note that if bHeaderOnly is set to true, the member variable <a class="el" href="class_c_byte_image.html#a05e313b4e6bb6d8d032ada9d5357a870" title="Flag signaling if memory is to be freed or not. ">CByteImage::m_bOwnMemory</a> is set to false so that memory assigned to the member variable <a class="el" href="class_c_byte_image.html#a0393555a29bdcb652481cdb7ee44fd1b" title="The pointer to the the pixels. ">CByteImage::pixels</a> is not freed throughout re-initialization/destruction, i.e. freeing memory must be handled by the caller in this case. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_byte_image_8cpp_source.html#l00168">168</a> of file <a class="el" href="_byte_image_8cpp_source.html">ByteImage.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a60d0d2b65dbd19cff2aff10eb7f01a76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CByteImage::bytesPerPixel</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of bytes used for encoding one pixel. </p>
<p>This information is redundant with the member type (ImageType::eGrayScale =&gt; 1; ImageType::eRGB24, ImageType::eRGB24Split =&gt; 3).</p>
<p>This variable should only be read. It should only be modified by external image loaders (e.g. <a class="el" href="namespace_image_access_c_v.html#a62777e2a43c95f68e6cc9b31d44d51eb" title="Loads an image from a file. ">ImageAccessCV::LoadFromFile</a>). </p>

<p>Definition at line <a class="el" href="_byte_image_8h_source.html#l00273">273</a> of file <a class="el" href="_byte_image_8h_source.html">ByteImage.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad83b58f53758148e02582ba20b59dbf3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CByteImage::height</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The height of the image in pixels. </p>
<p>This variable should only be read. It should only be modified by external image loaders (e.g. <a class="el" href="namespace_image_access_c_v.html#a62777e2a43c95f68e6cc9b31d44d51eb" title="Loads an image from a file. ">ImageAccessCV::LoadFromFile</a>). </p>

<p>Definition at line <a class="el" href="_byte_image_8h_source.html#l00264">264</a> of file <a class="el" href="_byte_image_8h_source.html">ByteImage.h</a>.</p>

</div>
</div>
<a class="anchor" id="a05e313b4e6bb6d8d032ada9d5357a870"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CByteImage::m_bOwnMemory</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flag signaling if memory is to be freed or not. </p>
<p>This flag signals whether the image memory must be freed throughut re-initiallization/destruction or not.</p>
<p>This flag is usually for internal use only. It should only be modified by external image loaders (e.g. <a class="el" href="namespace_image_access_c_v.html#a62777e2a43c95f68e6cc9b31d44d51eb" title="Loads an image from a file. ">ImageAccessCV::LoadFromFile</a>). </p>

<p>Definition at line <a class="el" href="_byte_image_8h_source.html#l00301">301</a> of file <a class="el" href="_byte_image_8h_source.html">ByteImage.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0393555a29bdcb652481cdb7ee44fd1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char* CByteImage::pixels</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The pointer to the the pixels. </p>
<p>This is the pointer pointing to the memory area containing the pixels of the image, starting from the top left corner and stored row wise (see above for type dependent information).</p>
<p>This variable should only be read. It should only be modified by external image loaders (e.g. <a class="el" href="namespace_image_access_c_v.html#a62777e2a43c95f68e6cc9b31d44d51eb" title="Loads an image from a file. ">ImageAccessCV::LoadFromFile</a>). </p>

<p>Definition at line <a class="el" href="_byte_image_8h_source.html#l00283">283</a> of file <a class="el" href="_byte_image_8h_source.html">ByteImage.h</a>.</p>

</div>
</div>
<a class="anchor" id="a89c8cddbca2d69a8b21da51ada8d70c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_byte_image.html#a694d6dc28b747d8a972130106a529f9e">ImageType</a> CByteImage::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the image. </p>
<p>The type of the image specifies its encoding. See above for type dependent information.</p>
<p>This variable should only be read. It should only be modified by external image loaders (e.g. <a class="el" href="namespace_image_access_c_v.html#a62777e2a43c95f68e6cc9b31d44d51eb" title="Loads an image from a file. ">ImageAccessCV::LoadFromFile</a>). </p>

<p>Definition at line <a class="el" href="_byte_image_8h_source.html#l00292">292</a> of file <a class="el" href="_byte_image_8h_source.html">ByteImage.h</a>.</p>

</div>
</div>
<a class="anchor" id="aeb83a0ce3987f6a45207fba0d211dbeb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CByteImage::width</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The width of the image in pixels. </p>
<p>Padding is not implemented (on purpose).</p>
<p>This variable should only be read. It should only be modified by external image loaders (e.g. <a class="el" href="namespace_image_access_c_v.html#a62777e2a43c95f68e6cc9b31d44d51eb" title="Loads an image from a file. ">ImageAccessCV::LoadFromFile</a>). </p>

<p>Definition at line <a class="el" href="_byte_image_8h_source.html#l00257">257</a> of file <a class="el" href="_byte_image_8h_source.html">ByteImage.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/Image/<a class="el" href="_byte_image_8h_source.html">ByteImage.h</a></li>
<li>src/Image/<a class="el" href="_byte_image_8cpp_source.html">ByteImage.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_c_byte_image.html">CByteImage</a></li>
    <li class="footer">Generated on Tue Feb 25 2014 18:06:18 for IVT by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
